①asks：消息可靠性，指明必须要有多个分区收到了消息才表示生产者发送消息成功（默认值为1）
0：表示生产者不管消息是否发送成功
1:表示集群情况下，首领分区收到了消息kafka就会向消费者发送应答，表示消息发送成功了，如果发送过程中首领分区死机了（kafka会在下一秒选出新的首领分区），会给生产者抛出异常，生产者应该在异常情况下重发消息
all：表示集群下所有的分区都要收到消息才表示消息发送成功。可靠性最高，延迟最高
ps：重要的消息就要使用all，无所谓的消息使用0，一般的消息可以使用1.
拓展：
分布式集群：多集群跨机架和跨城市。机架感知


②buffer.memory(默认值32M=33550000B)
kafka中设计生产者不会因为调用一个send方法而发送消息，会根据生产者缓冲区中堆积的多个消息的大小是否有32M而发送
把消息按批次发送到kafka的条件有好几个，如果该发送消息的时间到了，缓冲区的消息没有32m，也会发送出去
如果生产者生产消息太快，超出了32M，将阻塞或者异常


③max.block.ms（默认6000ms）
生产者连接kafka集群获取连接后的kafka元数据，如果没有获取成功，生产者会等待设定的时间后，超过时间抛出timeoutException

④retries重试次数(默认值为0)
生产者发送消息后可重复的次，每次重发中间间隔一定的时间。间隔时间参考retry.backoff.ms

⑤retry.backoff.ms（默认值100ms）
消息重发间隔时间

⑥batch.size （默认值16k）
一个批次的最大内存大小，注意不是消息的数量，而是消息占用内存的大小综合。要根据业务谨慎考虑设置该值

⑦linger.ms （默认值0）
发送批次消息的最晚时间；谨慎考虑，值越大，消息吞吐量越高，但是消息延迟也变高了。因此要根据业务谨慎考虑设置该值

batch.size 和linger.ms，谁先满足就会发送批次消息

⑧compression.type（默认值none）
压缩类型：
none：不压缩
gzip：cpu占用比较多，压缩比例高
snappy：cpu占用比较少，压缩比例低
如果带宽比较紧张选择gzip，如果cpu比较紧张选择snappy

⑨client.id
客户端标识符，对性能没有影响，做消息跟踪使用，根据业务而设计

⑩max.in.flight.requsts.per.connection
表示生产者在发送消息未获得的应答之前可以发送多少个消息，值越大内存占用越大，吞吐量也提高了。
为了保证消息在分区上的顺序时，max.in.flight.requsts.per.connection应该设置为1.并且分区只有一个，不同的分区也是无法保证顺序性的。

①①max.request.size
生产者发送消息的大小。
如果设置为1M，如果一个请求只有一个消息，name这个消息必须小于1M，如果一个请求中有1000个消息，name每个消息必须小于1k
ps：max.request.size的值必须参考server.properties文件的message.max.bytes值一致，
如果max.request.size>message.max.bytes,消息可能会发送失败。
